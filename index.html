<html lang="en">
    <script
        type="text/javascript"
        src="chrome-extension://ibniinmoafhgbifjojidlagmggecmpgf/dist/inject.js"
    ></script>
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=no"
        />
        <title>KTP Detection Camera</title>
        <script src="./inference.js"></script>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            html,
            body {
                overflow: hidden;
                height: 100%;
                width: 100%;
                margin: 0;
                padding: 0;
                background-color: #000;
            }
            #camera-container {
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }
            /* Canvas sekarang menjadi elemen visual utama */
            #display-canvas {
                width: 100%;
                height: 100%;
            }
            /* Elemen video sekarang disembunyikan, hanya sebagai sumber data */
            #viewfinder {
                position: absolute;
                left: -9999px;
            }
            #shutter-button:active {
                background-color: rgba(255, 255, 255, 0.3);
            }
            @keyframes flash-animation {
                from {
                    opacity: 0.7;
                }
                to {
                    opacity: 0;
                }
            }
            .flash-container {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: white;
                opacity: 0;
                pointer-events: none;
            }
            .flash {
                animation: flash-animation 0.3s ease-out;
            }
            #loader {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-size: 1.2rem;
                text-align: center;
                z-index: 20;
            }
        </style>
        <style>
            *,
            ::before,
            ::after {
                --tw-border-spacing-x: 0;
                --tw-border-spacing-y: 0;
                --tw-translate-x: 0;
                --tw-translate-y: 0;
                --tw-rotate: 0;
                --tw-skew-x: 0;
                --tw-skew-y: 0;
                --tw-scale-x: 1;
                --tw-scale-y: 1;
                --tw-pan-x: ;
                --tw-pan-y: ;
                --tw-pinch-zoom: ;
                --tw-scroll-snap-strictness: proximity;
                --tw-gradient-from-position: ;
                --tw-gradient-via-position: ;
                --tw-gradient-to-position: ;
                --tw-ordinal: ;
                --tw-slashed-zero: ;
                --tw-numeric-figure: ;
                --tw-numeric-spacing: ;
                --tw-numeric-fraction: ;
                --tw-ring-inset: ;
                --tw-ring-offset-width: 0px;
                --tw-ring-offset-color: #fff;
                --tw-ring-color: rgb(59 130 246 / 0.5);
                --tw-ring-offset-shadow: 0 0 #0000;
                --tw-ring-shadow: 0 0 #0000;
                --tw-shadow: 0 0 #0000;
                --tw-shadow-colored: 0 0 #0000;
                --tw-blur: ;
                --tw-brightness: ;
                --tw-contrast: ;
                --tw-grayscale: ;
                --tw-hue-rotate: ;
                --tw-invert: ;
                --tw-saturate: ;
                --tw-sepia: ;
                --tw-drop-shadow: ;
                --tw-backdrop-blur: ;
                --tw-backdrop-brightness: ;
                --tw-backdrop-contrast: ;
                --tw-backdrop-grayscale: ;
                --tw-backdrop-hue-rotate: ;
                --tw-backdrop-invert: ;
                --tw-backdrop-opacity: ;
                --tw-backdrop-saturate: ;
                --tw-backdrop-sepia: ;
                --tw-contain-size: ;
                --tw-contain-layout: ;
                --tw-contain-paint: ;
                --tw-contain-style: ;
            }
            ::backdrop {
                --tw-border-spacing-x: 0;
                --tw-border-spacing-y: 0;
                --tw-translate-x: 0;
                --tw-translate-y: 0;
                --tw-rotate: 0;
                --tw-skew-x: 0;
                --tw-skew-y: 0;
                --tw-scale-x: 1;
                --tw-scale-y: 1;
                --tw-pan-x: ;
                --tw-pan-y: ;
                --tw-pinch-zoom: ;
                --tw-scroll-snap-strictness: proximity;
                --tw-gradient-from-position: ;
                --tw-gradient-via-position: ;
                --tw-gradient-to-position: ;
                --tw-ordinal: ;
                --tw-slashed-zero: ;
                --tw-numeric-figure: ;
                --tw-numeric-spacing: ;
                --tw-numeric-fraction: ;
                --tw-ring-inset: ;
                --tw-ring-offset-width: 0px;
                --tw-ring-offset-color: #fff;
                --tw-ring-color: rgb(59 130 246 / 0.5);
                --tw-ring-offset-shadow: 0 0 #0000;
                --tw-ring-shadow: 0 0 #0000;
                --tw-shadow: 0 0 #0000;
                --tw-shadow-colored: 0 0 #0000;
                --tw-blur: ;
                --tw-brightness: ;
                --tw-contrast: ;
                --tw-grayscale: ;
                --tw-hue-rotate: ;
                --tw-invert: ;
                --tw-saturate: ;
                --tw-sepia: ;
                --tw-drop-shadow: ;
                --tw-backdrop-blur: ;
                --tw-backdrop-brightness: ;
                --tw-backdrop-contrast: ;
                --tw-backdrop-grayscale: ;
                --tw-backdrop-hue-rotate: ;
                --tw-backdrop-invert: ;
                --tw-backdrop-opacity: ;
                --tw-backdrop-saturate: ;
                --tw-backdrop-sepia: ;
                --tw-contain-size: ;
                --tw-contain-layout: ;
                --tw-contain-paint: ;
                --tw-contain-style: ;
            } /* ! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com */
            *,
            ::after,
            ::before {
                box-sizing: border-box;
                border-width: 0;
                border-style: solid;
                border-color: #e5e7eb;
            }
            ::after,
            ::before {
                --tw-content: "";
            }
            :host,
            html {
                line-height: 1.5;
                -webkit-text-size-adjust: 100%;
                -moz-tab-size: 4;
                tab-size: 4;
                font-family:
                    ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji",
                    "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
                font-feature-settings: normal;
                font-variation-settings: normal;
                -webkit-tap-highlight-color: transparent;
            }
            body {
                margin: 0;
                line-height: inherit;
            }
            hr {
                height: 0;
                color: inherit;
                border-top-width: 1px;
            }
            abbr:where([title]) {
                -webkit-text-decoration: underline dotted;
                text-decoration: underline dotted;
            }
            h1,
            h2,
            h3,
            h4,
            h5,
            h6 {
                font-size: inherit;
                font-weight: inherit;
            }
            a {
                color: inherit;
                text-decoration: inherit;
            }
            b,
            strong {
                font-weight: bolder;
            }
            code,
            kbd,
            pre,
            samp {
                font-family:
                    ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                    "Liberation Mono", "Courier New", monospace;
                font-feature-settings: normal;
                font-variation-settings: normal;
                font-size: 1em;
            }
            small {
                font-size: 80%;
            }
            sub,
            sup {
                font-size: 75%;
                line-height: 0;
                position: relative;
                vertical-align: baseline;
            }
            sub {
                bottom: -0.25em;
            }
            sup {
                top: -0.5em;
            }
            table {
                text-indent: 0;
                border-color: inherit;
                border-collapse: collapse;
            }
            button,
            input,
            optgroup,
            select,
            textarea {
                font-family: inherit;
                font-feature-settings: inherit;
                font-variation-settings: inherit;
                font-size: 100%;
                font-weight: inherit;
                line-height: inherit;
                letter-spacing: inherit;
                color: inherit;
                margin: 0;
                padding: 0;
            }
            button,
            select {
                text-transform: none;
            }
            button,
            input:where([type="button"]),
            input:where([type="reset"]),
            input:where([type="submit"]) {
                -webkit-appearance: button;
                background-color: transparent;
                background-image: none;
            }
            :-moz-focusring {
                outline: auto;
            }
            :-moz-ui-invalid {
                box-shadow: none;
            }
            progress {
                vertical-align: baseline;
            }
            ::-webkit-inner-spin-button,
            ::-webkit-outer-spin-button {
                height: auto;
            }
            [type="search"] {
                -webkit-appearance: textfield;
                outline-offset: -2px;
            }
            ::-webkit-search-decoration {
                -webkit-appearance: none;
            }
            ::-webkit-file-upload-button {
                -webkit-appearance: button;
                font: inherit;
            }
            summary {
                display: list-item;
            }
            blockquote,
            dd,
            dl,
            figure,
            h1,
            h2,
            h3,
            h4,
            h5,
            h6,
            hr,
            p,
            pre {
                margin: 0;
            }
            fieldset {
                margin: 0;
                padding: 0;
            }
            legend {
                padding: 0;
            }
            menu,
            ol,
            ul {
                list-style: none;
                margin: 0;
                padding: 0;
            }
            dialog {
                padding: 0;
            }
            textarea {
                resize: vertical;
            }
            input::placeholder,
            textarea::placeholder {
                opacity: 1;
                color: #9ca3af;
            }
            [role="button"],
            button {
                cursor: pointer;
            }
            :disabled {
                cursor: default;
            }
            audio,
            canvas,
            embed,
            iframe,
            img,
            object,
            svg,
            video {
                display: block;
                vertical-align: middle;
            }
            img,
            video {
                max-width: 100%;
                height: auto;
            }
            [hidden]:where(:not([hidden="until-found"])) {
                display: none;
            }
            .absolute {
                position: absolute;
            }
            .relative {
                position: relative;
            }
            .right-8 {
                right: 2rem;
            }
            .z-10 {
                z-index: 10;
            }
            .flex {
                display: flex;
            }
            .h-screen {
                height: 100vh;
            }
            .h-14 {
                height: 3.5rem;
            }
            .h-20 {
                height: 5rem;
            }
            .h-28 {
                height: 7rem;
            }
            .w-screen {
                width: 100vw;
            }
            .w-14 {
                width: 3.5rem;
            }
            .w-20 {
                width: 5rem;
            }
            .flex-grow {
                flex-grow: 1;
            }
            .flex-col {
                flex-direction: column;
            }
            .items-center {
                align-items: center;
            }
            .justify-center {
                justify-content: center;
            }
            .rounded-full {
                border-radius: 9999px;
            }
            .border-4 {
                border-width: 4px;
            }
            .border-white {
                --tw-border-opacity: 1;
                border-color: rgb(255 255 255 / var(--tw-border-opacity, 1));
            }
            .bg-black {
                --tw-bg-opacity: 1;
                background-color: rgb(0 0 0 / var(--tw-bg-opacity, 1));
            }
            .p-4 {
                padding: 1rem;
            }
            .transition-colors {
                transition-property:
                    color,
                    background-color,
                    border-color,
                    fill,
                    stroke,
                    -webkit-text-decoration-color;
                transition-property:
                    color, background-color, border-color,
                    text-decoration-color, fill, stroke;
                transition-property:
                    color,
                    background-color,
                    border-color,
                    text-decoration-color,
                    fill,
                    stroke,
                    -webkit-text-decoration-color;
                transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
                transition-duration: 150ms;
            }
            .focus\:outline-none:focus {
                outline: 2px solid transparent;
                outline-offset: 2px;
            }
        </style>
    </head>
    <body class="bg-black flex flex-col h-screen w-screen">
        <main id="camera-container" class="flex-grow">
            <video id="viewfinder" autoplay="" muted="" playsinline=""></video>
            <canvas id="display-canvas" width="512" height="815"></canvas>
            <div id="flash-overlay" class="flash-container"></div>
            <div id="loader" style="display: none">
                Memuat Model Deteksi KTP...
            </div>
        </main>

        <footer
            class="h-28 flex justify-center items-center p-4 z-10 relative bg-black"
        >
            <button
                id="shutter-button"
                class="w-20 h-20 rounded-full border-4 border-white focus:outline-none transition-colors"
            ></button>
            <button
                id="switch-camera-button"
                class="absolute right-8 w-14 h-14 flex items-center justify-center focus:outline-none"
            >
                <svg
                    class="icon"
                    viewBox="0 0 1024 1024"
                    xmlns="http://www.w3.org/2000/svg"
                    width="200"
                    height="200"
                >
                    <path
                        d="M872.1 197.6 684.4 72.5c-5.3-3.5-12.4.3-12.4 6.7V160H384C207.3 160 64 303.3 64 480v64c0 45.9 9.7 89.6 27.1 129 2 4.6 7.6 6.2 11.8 3.5l95.4-63.6c3-2 4.3-5.7 3.2-9.2-6.2-19-9.4-39.1-9.4-59.7v-64c0-51.3 20-99.5 56.2-135.8C284.5 308 332.7 288 384 288h288v81.3c0 6.4 7.1 10.2 12.4 6.7L872 250.9c19.1-12.7 19.1-40.6.1-53.3M151.2 833.3l187.6 125.1c5.3 3.5 12.4-.3 12.4-6.7v-80.8h288c176.7 0 320-143.3 320-320v-64c0-45.9-9.7-89.6-27.1-129-2-4.6-7.6-6.2-11.8-3.5L825 418c-3 2-4.3 5.7-3.2 9.2 6.2 19 9.4 39.1 9.4 59.7v64c0 51.3-20 99.5-56.2 135.8-36.3 36.3-84.5 56.2-135.8 56.2h-288v-81.3c0-6.4-7.1-10.2-12.4-6.7L151.2 780c-18.9 12.7-18.9 40.6 0 53.3"
                        fill="white"
                    ></path>
                </svg>
            </button>
        </footer>

        <script>
            const viewfinder = document.getElementById("viewfinder");
            const displayCanvas = document.getElementById("display-canvas");
            const shutterButton = document.getElementById("shutter-button");
            const switchCameraButton = document.getElementById(
                "switch-camera-button",
            );
            const flashOverlay = document.getElementById("flash-overlay");
            const loader = document.getElementById("loader");

            let currentStream;
            let facingMode = "environment";

            const { InferenceEngine, CVImage } = inferencejs;
            let inferEngine;
            let workerId;
            let lastPredictions = [];

            const MODEL_ID = "indonesia-id-card";
            const MODEL_VERSION = "1";
            const MODEL_URL =
                "https://cdn.jsdelivr.net/gh/agusibrahim/live-ktp-detection@main/assets/models.json";

            // --- CHECKPOINT 4: Variabel Kontrol untuk Border Fokus ---
            const TAMPILKAN_KOTAK_DEBUG = false;
            const FOKUS_PADDING = 0;
            const FOKUS_SUDUT_MELENGKUNG = 16;
            const FOKUS_BORDER_TEBAL = 4; // Ketebalan border
            const FOKUS_BORDER_WARNA = "rgba(255, 255, 255, 0.9)"; // Warna border (putih semi-transparan)

            const KTP_ASPECT_RATIO = 1.586;
            const ASPECT_RATIO_TOLERANCE = 0.05;

            async function loadModel() {
                try {
                    inferEngine = new InferenceEngine();
                    workerId = await inferEngine.startWorker(
                        MODEL_ID,
                        MODEL_VERSION,
                        MODEL_URL,
                    );
                    loader.style.display = "none";
                    console.log("KTP Detection Model loaded.");
                    detectFrame();
                    renderLoop();
                } catch (err) {
                    console.error("Failed to load model", err);
                    loader.innerText = "Gagal memuat model.";
                }
            }

            async function detectFrame() {
                if (
                    !workerId ||
                    viewfinder.paused ||
                    viewfinder.ended ||
                    viewfinder.videoWidth === 0
                ) {
                    requestAnimationFrame(detectFrame);
                    return;
                }
                try {
                    const image = new CVImage(viewfinder);
                    lastPredictions = await inferEngine.infer(workerId, image);
                } catch (err) {
                    // Inference can fail, just continue
                } finally {
                    requestAnimationFrame(detectFrame);
                }
            }

            function renderLoop() {
                const ctx = displayCanvas.getContext("2d");

                displayCanvas.width = displayCanvas.clientWidth;
                displayCanvas.height = displayCanvas.clientHeight;

                if (viewfinder.videoWidth === 0) {
                    requestAnimationFrame(renderLoop);
                    return;
                }

                const videoRatio =
                    viewfinder.videoWidth / viewfinder.videoHeight;
                const canvasRatio = displayCanvas.width / displayCanvas.height;
                let srcX = 0,
                    srcY = 0,
                    srcWidth = viewfinder.videoWidth,
                    srcHeight = viewfinder.videoHeight;

                if (videoRatio > canvasRatio) {
                    srcWidth = viewfinder.videoHeight * canvasRatio;
                    srcX = (viewfinder.videoWidth - srcWidth) / 2;
                } else {
                    srcHeight = viewfinder.videoWidth / canvasRatio;
                    srcY = (viewfinder.videoHeight - srcHeight) / 2;
                }

                ctx.drawImage(
                    viewfinder,
                    srcX,
                    srcY,
                    srcWidth,
                    srcHeight,
                    0,
                    0,
                    displayCanvas.width,
                    displayCanvas.height,
                );

                const scaleX = displayCanvas.width / srcWidth;
                const scaleY = displayCanvas.height / srcHeight;

                const ktpCandidates = lastPredictions.filter(
                    (p) => p.class === "ktp",
                );
                const faceCandidates = lastPredictions.filter(
                    (p) => p.class === "wajah",
                );

                let validKtps = [];
                ktpCandidates.forEach((ktp) => {
                    const currentRatio = ktp.bbox.width / ktp.bbox.height;
                    const lowerBound =
                        KTP_ASPECT_RATIO * (1 - ASPECT_RATIO_TOLERANCE);
                    const upperBound =
                        KTP_ASPECT_RATIO * (1 + ASPECT_RATIO_TOLERANCE);
                    if (currentRatio < lowerBound || currentRatio > upperBound)
                        return;

                    const ktpMinX = ktp.bbox.x - ktp.bbox.width / 2;
                    const ktpMinY = ktp.bbox.y - ktp.bbox.height / 2;
                    const ktpMaxX = ktp.bbox.x + ktp.bbox.width / 2;
                    const ktpMaxY = ktp.bbox.y + ktp.bbox.height / 2;

                    const hasFaceInside = faceCandidates.some((face) => {
                        const faceMinX = face.bbox.x - face.bbox.width / 2;
                        const faceMinY = face.bbox.y - face.bbox.height / 2;
                        const faceMaxX = face.bbox.x + face.bbox.width / 2;
                        const faceMaxY = face.bbox.y + face.bbox.height / 2;
                        return (
                            faceMinX >= ktpMinX &&
                            faceMaxX <= ktpMaxX &&
                            faceMinY >= ktpMinY &&
                            faceMaxY <= ktpMaxY
                        );
                    });

                    if (hasFaceInside) {
                        validKtps.push(ktp);
                    }
                });

                let focusedKtp = null;
                if (validKtps.length > 0) {
                    focusedKtp = validKtps.reduce((prev, current) =>
                        prev.bbox.width * prev.bbox.height >
                        current.bbox.width * current.bbox.height
                            ? prev
                            : current,
                    );
                }

                if (focusedKtp) {
                    const ktpX =
                        (focusedKtp.bbox.x - focusedKtp.bbox.width / 2 - srcX) *
                            scaleX -
                        FOKUS_PADDING;
                    const ktpY =
                        (focusedKtp.bbox.y -
                            focusedKtp.bbox.height / 2 -
                            srcY) *
                            scaleY -
                        FOKUS_PADDING;
                    const ktpWidth =
                        focusedKtp.bbox.width * scaleX + FOKUS_PADDING * 2;
                    const ktpHeight =
                        focusedKtp.bbox.height * scaleY + FOKUS_PADDING * 2;

                    ctx.save();
                    ctx.beginPath();
                    // Membuat path untuk lubang fokus
                    ctx.roundRect(
                        ktpX,
                        ktpY,
                        ktpWidth,
                        ktpHeight,
                        FOKUS_SUDUT_MELENGKUNG,
                    );
                    // Membuat path untuk area luar
                    ctx.rect(
                        displayCanvas.width,
                        0,
                        -displayCanvas.width,
                        displayCanvas.height,
                    );
                    // Mengisi area gelap di antara dua path
                    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    ctx.fill("evenodd");
                    ctx.restore();

                    // --- CHECKPOINT 4: Gambar Border di Sekeliling Lubang Fokus ---
                    ctx.beginPath();
                    ctx.roundRect(
                        ktpX,
                        ktpY,
                        ktpWidth,
                        ktpHeight,
                        FOKUS_SUDUT_MELENGKUNG,
                    );
                    ctx.strokeStyle = FOKUS_BORDER_WARNA;
                    ctx.lineWidth = FOKUS_BORDER_TEBAL;
                    ctx.stroke();
                }

                if (TAMPILKAN_KOTAK_DEBUG) {
                    const font = "16px sans-serif";
                    lastPredictions.forEach((prediction) => {
                        const drawX =
                            (prediction.bbox.x -
                                prediction.bbox.width / 2 -
                                srcX) *
                            scaleX;
                        const drawY =
                            (prediction.bbox.y -
                                prediction.bbox.height / 2 -
                                srcY) *
                            scaleY;
                        const drawWidth = prediction.bbox.width * scaleX;
                        const drawHeight = prediction.bbox.height * scaleY;

                        ctx.strokeStyle = prediction.color;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(drawX, drawY, drawWidth, drawHeight);

                        ctx.fillStyle = prediction.color;
                        const textWidth = ctx.measureText(
                            prediction.class,
                        ).width;
                        const textHeight = parseInt(font, 10);
                        ctx.fillRect(
                            drawX,
                            drawY,
                            textWidth + 4,
                            textHeight + 2,
                        );
                        ctx.font = font;
                        ctx.textBaseline = "top";
                        ctx.fillStyle = "#000000";
                        ctx.fillText(prediction.class, drawX + 2, drawY);
                    });
                }

                requestAnimationFrame(renderLoop);
            }

            function stopStream() {
                if (currentStream) {
                    currentStream.getTracks().forEach((track) => track.stop());
                }
            }

            async function startCamera() {
                stopStream();
                const constraints = {
                    audio: false,
                    video: {
                        facingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                    },
                };
                try {
                    currentStream =
                        await navigator.mediaDevices.getUserMedia(constraints);
                    viewfinder.srcObject = currentStream;
                    await viewfinder.play();
                } catch (err) {
                    console.error("Error accessing camera: ", err);
                    loader.innerText = "Tidak dapat mengakses kamera.";
                }
            }

            function switchCamera() {
                facingMode =
                    facingMode === "environment" ? "user" : "environment";
                startCamera();
            }

            function takePhoto() {
                const dataUrl = displayCanvas.toDataURL("image/jpeg");
                console.log("Photo taken:", dataUrl.substring(0, 50) + "...");
                flashOverlay.classList.add("flash");
                setTimeout(() => flashOverlay.classList.remove("flash"), 300);
            }

            shutterButton.addEventListener("click", takePhoto);
            switchCameraButton.addEventListener("click", switchCamera);

            window.addEventListener("load", () => {
                startCamera();
                loadModel();
            });
        </script>

        <browser-mcp-container data-wxt-shadow-root=""></browser-mcp-container>
    </body>
</html>
